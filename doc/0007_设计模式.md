### 设计模式
#### 六大原则镇楼
- 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放
- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因
- 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能
- 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成
- 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话
- 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法
#### UML
##### 看懂UML类图
![UML类图](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/uml.png)<br>
如图，解释如下：<br>
- 最上面的车，标注为抽象类，说明其不能直接产生对象，需要由子类继承后，才能用来定义对象<br>
- 下面的小汽车和自行车为车（抽象类）的继承类，之间用带空心三角箭头的虚线连接，表示关系为**实现关系**（从抽象类继承）<br>
- SUV为小汽车（非抽象类）的继承类，之间用带空心三角箭头的实线连接，表示关系为**泛化关系**（从非抽象类继承）<br>
- 小汽车于发动机、轮胎之间用带实心菱形箭头的实线连接，表示关系是**组合关系**（强依赖，小汽车作为整体不存在了，则发动机和轮胎作为部分也就不存在了）<br>
- 学生和班级之间用带空心菱形箭头的实线连接，表示关系为**聚合关系**（非强依赖，班级不见了，学生也还会在）<br>
- 学生和自行车直接用带不封闭三角箭头的虚线连接，表示关系为**依赖关系**（一种临时性关系，表明临时性使用关系，依赖也有方向，但是我们应该总是保持单向依赖而杜绝双向依赖）（传参）<br>
- 学生与身份证之间使用无箭头的实线连接，表示关系为**关联关系**（一种静态关系，代表着常识中我们认为相互关联的存在，比如学生和学校、医院和医生，默认不带方向，不过可以添加单向带不封闭三角箭头的实线代表箭头出发方知道目的方，反之则不知道）（成员变量）<br>
>参考自博客  [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)<br>
##### 看懂UML时序图
![UML时序图](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/umltime.png)<br>
如图，时序图包括四个元素：<br>
- **对象**，用中间有对象名称的矩形框表示，对象名称下有下划线；若在顶部则说明交互前就存在，若不在顶部则说明在交互中产生<br>
- **生命线**，用一条垂直的虚线表示，在时序图中，每个对象都有生命线，生命线在X符号处截断，代表撤销对象<br>
- **激活**，用中间没有内容的矩形框表示，处于生命线上，表明该对象被占用以完成某个任务<br>
- **消息**，用激活矩形框之间的箭头表示，用带非封闭箭头的实线表示`两个对象间绘制消息`，用带封闭箭头的实线表示`两个对象之间的过程调用`，用带一半箭头的实线表示`两个对象间的异步消息`，用虚线箭头表示`过程调用中返回的消息`，用带箭头的转弯实线表示`绘制反身消息`<br>
>参考自博客  [时序图](https://www.jianshu.com/p/ccc0084cfb76)<br>
#### 创建型模式
##### 简单工厂模式
简单工厂模式中，专门定义一个类作为所有其他类的父类，根据参数的不同返回不同类的实例<br>
>一个软件系统可以提供多个**外观不同的按钮**（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都**源自同一个基类**，不过在继承基类后不同的子类**修改了部分属性**从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的**一个参数**，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用**简单工厂模式**<br>

即：一个工厂生产所有不同的产品，要哪个产品你告诉它，它直接生产给你
##### 工厂方法模式
工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象<br>
>不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，**圆形按钮工厂生产圆形按钮，菱形按钮工厂生产菱形按钮**，如果要添加新形状的按钮，**只需要添加新的工厂**即可，如果要修改某种按钮的生产，**只需要修改对应的工厂**，不需要像简单工厂模式那样每次都**对整个工厂进行修改**

即：不同工厂各自生产对应的产品，要哪个产品就找哪个工厂，它直接生产给你<br>
##### 抽象工厂模式
抽象工厂模式中，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类<br>
>有时候我们需要**一个工厂可以提供多个产品对象**，而不是单一的产品对象，此处引入两个概念：<br>
>- 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个**产品等级结构**，抽象电视机是父类，而具体品牌的电视机是其子类<br>
>- 产品族 ：在抽象工厂模式中，产品族是指由**同一个工厂生产**的，**位于不同产品等级结构**的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔洗衣机就构成一个产品族，三者分别位于电视机产品等级结构、电冰箱产品等级结构和洗衣机产品等级结构<br>
![产品族](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/products.png)<br>
图源博客[产品族和产品等级结构](https://www.jianshu.com/p/f1e837cab952)<br>

>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建

即：同一个产品族的一间工厂合并成一个超级工厂，这个超级工厂可以生产各类产品，相当于上面这个4*3=12个工厂，被组合成了4个超级工厂，每个超级工厂都可以生产所有形状的产品，但是生产出的颜色各有各的特色<br>
