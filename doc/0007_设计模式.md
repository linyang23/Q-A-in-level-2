### 设计模式
#### 六大原则镇楼
- 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放
- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因
- 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能
- 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成
- 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话
- 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法
#### UML
##### 看懂UML类图
![UML类图](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/uml.png)<br>
如图，解释如下：<br>
- 最上面的车，标注为抽象类，说明其不能直接产生对象，需要由子类继承后，才能用来定义对象<br>
- 下面的小汽车和自行车为车（抽象类）的继承类，之间用带空心三角箭头的虚线连接，表示关系为**实现关系**（从抽象类继承）<br>
- SUV为小汽车（非抽象类）的继承类，之间用带空心三角箭头的实线连接，表示关系为**泛化关系**（从非抽象类继承）<br>
- 小汽车于发动机、轮胎之间用带实心菱形箭头的实线连接，表示关系是**组合关系**（强依赖，小汽车作为整体不存在了，则发动机和轮胎作为部分也就不存在了）<br>
- 学生和班级之间用带空心菱形箭头的实线连接，表示关系为**聚合关系**（非强依赖，班级不见了，学生也还会在）<br>
- 学生和自行车直接用带不封闭三角箭头的虚线连接，表示关系为**依赖关系**（一种临时性关系，表明临时性使用关系，依赖也有方向，但是我们应该总是保持单向依赖而杜绝双向依赖）（传参）<br>
- 学生与身份证之间使用无箭头的实线连接，表示关系为**关联关系**（一种静态关系，代表着常识中我们认为相互关联的存在，比如学生和学校、医院和医生，默认不带方向，不过可以添加单向带不封闭三角箭头的实线代表箭头出发方知道目的方，反之则不知道）（成员变量）<br>
>参考自博客  [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)<br>
##### 看懂UML时序图
![UML时序图](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/umltime.png)<br>
如图，时序图包括四个元素：<br>
- **对象**，用中间有对象名称的矩形框表示，对象名称下有下划线；若在顶部则说明交互前就存在，若不在顶部则说明在交互中产生<br>
- **生命线**，用一条垂直的虚线表示，在时序图中，每个对象都有生命线，生命线在X符号处截断，代表撤销对象<br>
- **激活**，用中间没有内容的矩形框表示，处于生命线上，表明该对象被占用以完成某个任务<br>
- **消息**，用激活矩形框之间的箭头表示，用带非封闭箭头的实线表示`两个对象间绘制消息`，用带封闭箭头的实线表示`两个对象之间的过程调用`，用带一半箭头的实线表示`两个对象间的异步消息`，用虚线箭头表示`过程调用中返回的消息`，用带箭头的转弯实线表示`绘制反身消息`<br>
>参考自博客  [时序图](https://www.jianshu.com/p/ccc0084cfb76)<br>
#### 创建型模式
##### 简单工厂模式
简单工厂模式中，专门定义一个类作为所有其他类的父类，根据参数的不同返回不同类的实例<br>
以前：直接new对象，比如苹果或梨子，我们需要知道苹果或梨子的构造方法<br>
使用工厂模式：把这部分生产工作交给了工厂，我们需要做的就是通知工厂给我们生产苹果或梨子，不需要知道到底是怎么制造的<br>
>一个软件系统可以提供多个**外观不同的按钮**（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都**源自同一个基类**，不过在继承基类后不同的子类**修改了部分属性**从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的**一个参数**，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用**简单工厂模式**<br>

即：**一个工厂生产所有不同的产品，要哪个产品你告诉它，它直接生产给你**
##### 工厂方法模式
工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象<br>
以前的简单工厂模式：所有苹果和梨子都在一个工厂生产<br>
使用工厂方法模式：苹果在苹果工厂生产，梨子在梨子工厂生产<br>
>不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，**圆形按钮工厂生产圆形按钮，菱形按钮工厂生产菱形按钮**，如果要添加新形状的按钮，**只需要添加新的工厂**即可，如果要修改某种按钮的生产，**只需要修改对应的工厂**，不需要像简单工厂模式那样每次都**对整个工厂进行修改**

即：**不同工厂各自生产对应的产品，要哪个产品就找哪个工厂，它直接生产给你**<br>
##### 抽象工厂模式
抽象工厂模式中，提供一个创建一系列**相关或相互依赖对象**的接口，而无须指定它们具体的类<br>
以前的模式：要买什么，就通知对应的工厂生产<br>
现在的模式：工厂不直接跟用户打交道，一系列工厂成立了采购处，所有客户都通过采购处购买，告知要买什么，采购处就通知能生产该物品的工厂生产，这样客户不知道内部情况，只管购买就行了<br>
>有时候我们需要**一个工厂可以提供多个产品对象**，而不是单一的产品对象，此处引入两个概念：<br>
>- 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个**产品等级结构**，抽象电视机是父类，而具体品牌的电视机是其子类<br>
>- 产品族 ：在抽象工厂模式中，产品族是指由**同一个工厂生产**的，**位于不同产品等级结构**的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔洗衣机就构成一个产品族，三者分别位于电视机产品等级结构、电冰箱产品等级结构和洗衣机产品等级结构<br>
![产品族](https://github.com/linyang23/Q-A-in-level-2/blob/master/photo/products.png)<br>
图源博客[产品族和产品等级结构](https://www.jianshu.com/p/f1e837cab952)<br>

>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建

即：**同一个产品族的一间工厂合并成一个超级工厂，这个超级工厂可以生产各类产品**，相当于上面这个4*3=12个工厂，被组合成了4个超级工厂，每个超级工厂都可以生产所有形状的产品，但是生产出的内部花纹各有各的特色<br>
##### 建造者模式
建造者模式中，将一个复杂对象的构建与它的表示分离，使得**同样的构建过程**可以创建不同的表示<br>
比如买奶茶，菜单勾选好可选项，比如大杯还是中杯，高糖还是低糖，加不加珍珠等，然后生产方按照稳定的流程步骤生产，比如先制冰，然后加奶...最后打包给客户<br>
>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式<br>

即：**要生产什么种类很多的东西，你只需要勾选或不勾选一些可选配置，其他的制作流程稳定**
##### 单例模式
单例模式中，**确保某一个类只有一个实例**，而且自行实例化并向整个系统提供这个实例<br>
>例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器<br>

即：**你要什么，我给什么，但是只能给一个**<br>
##### 原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>
比如你是周杰伦歌迷，你到奶茶点说给我来一份周杰伦同款，于是奶茶点按照周杰伦那份已经做好的奶茶来判断可选项是什么，并以此做一份一摸一样的给你<br>
#### 结构型模式
##### 适配器模式
将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作<br>
比如：充电头220v转化为手机需要的5v
##### 桥接模式
将抽象部分与它的实现部分分离，使它们都可以独立地变化<br>
##### 装饰模式
动态地给一个对象增加一些额外的职责<br>
##### 外观模式
外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面<br>
##### 享元模式
：运用共享技术有效地支持大量细粒度对象的复用<br>
##### 代理模式
给某一个对象提供一个代理，并由代理对象控制对原对象的引用<br>
#### 行为型模式
##### 命令模式
将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化<br>
##### 中介者模式
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互<br>
##### 观察者模式
定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新<br>
##### 状态模式
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类<br>
##### 策略模式
定义一系列算法，将每一个算法封装起来，并让它们可以相互替换<br>